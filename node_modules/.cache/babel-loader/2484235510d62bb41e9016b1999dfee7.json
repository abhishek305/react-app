{"ast":null,"code":"// The MIT License (MIT)\n// Typed.js | Copyright (c) 2014 Matt Boldt | www.mattboldt.com\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n!function ($) {\n  \"use strict\";\n\n  var Typed = function (el, options) {\n    // chosen element to manipulate text\n    this.el = $(el); // options\n\n    this.options = $.extend({}, $.fn.typed.defaults, options); // attribute to type into\n\n    this.isInput = this.el.is('input');\n    this.attr = this.options.attr; // show cursor\n\n    this.showCursor = this.isInput ? false : this.options.showCursor; // text content of element\n\n    this.elContent = this.attr ? this.el.attr(this.attr) : this.el.text(); // html or plain text\n\n    this.contentType = this.options.contentType; // typing speed\n\n    this.typeSpeed = this.options.typeSpeed; // add a delay before typing starts\n\n    this.startDelay = this.options.startDelay; // backspacing speed\n\n    this.backSpeed = this.options.backSpeed; // amount of time to wait before backspacing\n\n    this.backDelay = this.options.backDelay; // div containing strings\n\n    this.stringsElement = this.options.stringsElement; // input strings of text\n\n    this.strings = this.options.strings; // character number position of current string\n\n    this.strPos = 0; // current array position\n\n    this.arrayPos = 0; // number to stop backspacing on.\n    // default 0, can change depending on how many chars\n    // you want to remove at the time\n\n    this.stopNum = 0; // Looping logic\n\n    this.loop = this.options.loop;\n    this.loopCount = this.options.loopCount;\n    this.curLoop = 0; // for stopping\n\n    this.stop = false; // custom cursor\n\n    this.cursorChar = this.options.cursorChar; // shuffle the strings\n\n    this.shuffle = this.options.shuffle; // the order of strings\n\n    this.sequence = []; // All systems go!\n\n    this.build();\n  };\n\n  Typed.prototype = {\n    constructor: Typed,\n    init: function () {\n      // begin the loop w/ first current string (global self.strings)\n      // current string will be passed as an argument each time after this\n      var self = this;\n      self.timeout = setTimeout(function () {\n        for (var i = 0; i < self.strings.length; ++i) self.sequence[i] = i; // shuffle the array if true\n\n\n        if (self.shuffle) self.sequence = self.shuffleArray(self.sequence); // Start typing\n\n        self.typewrite(self.strings[self.sequence[self.arrayPos]], self.strPos);\n      }, self.startDelay);\n    },\n    build: function () {\n      var self = this; // Insert cursor\n\n      if (this.showCursor === true) {\n        this.cursor = $(\"<span class=\\\"typed-cursor\\\">\" + this.cursorChar + \"</span>\");\n        this.el.after(this.cursor);\n      }\n\n      if (this.stringsElement) {\n        self.strings = [];\n        this.stringsElement.hide();\n        var strings = this.stringsElement.find('p');\n        $.each(strings, function (key, value) {\n          self.strings.push($(value).html());\n        });\n      }\n\n      this.init();\n    } // pass current string state to each function, types 1 char per call\n    ,\n    typewrite: function (curString, curStrPos) {\n      // exit when stopped\n      if (this.stop === true) {\n        return;\n      } // varying values for setTimeout during typing\n      // can't be global since number changes each time loop is executed\n\n\n      var humanize = Math.round(Math.random() * (100 - 30)) + this.typeSpeed;\n      var self = this; // ------------- optional ------------- //\n      // backpaces a certain string faster\n      // ------------------------------------ //\n      // if (self.arrayPos == 1){\n      //  self.backDelay = 50;\n      // }\n      // else{ self.backDelay = 500; }\n      // contain typing function in a timeout humanize'd delay\n\n      self.timeout = setTimeout(function () {\n        // check for an escape character before a pause value\n        // format: \\^\\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^\n        // single ^ are removed from string\n        var charPause = 0;\n        var substr = curString.substr(curStrPos);\n\n        if (substr.charAt(0) === '^') {\n          var skip = 1; // skip atleast 1\n\n          if (/^\\^\\d+/.test(substr)) {\n            substr = /\\d+/.exec(substr)[0];\n            skip += substr.length;\n            charPause = parseInt(substr);\n          } // strip out the escape character and pause value so they're not printed\n\n\n          curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);\n        }\n\n        if (self.contentType === 'html') {\n          // skip over html tags while typing\n          var curChar = curString.substr(curStrPos).charAt(0);\n\n          if (curChar === '<' || curChar === '&') {\n            var tag = '';\n            var endTag = '';\n\n            if (curChar === '<') {\n              endTag = '>';\n            } else {\n              endTag = ';';\n            }\n\n            while (curString.substr(curStrPos).charAt(0) !== endTag) {\n              tag += curString.substr(curStrPos).charAt(0);\n              curStrPos++;\n            }\n\n            curStrPos++;\n            tag += endTag;\n          }\n        } // timeout for any pause after a character\n\n\n        self.timeout = setTimeout(function () {\n          if (curStrPos === curString.length) {\n            // fires callback function\n            self.options.onStringTyped(self.arrayPos); // is this the final string\n\n            if (self.arrayPos === self.strings.length - 1) {\n              // animation that occurs on the last typed string\n              self.options.callback();\n              self.curLoop++; // quit if we wont loop back\n\n              if (self.loop === false || self.curLoop === self.loopCount) return;\n            }\n\n            self.timeout = setTimeout(function () {\n              self.backspace(curString, curStrPos);\n            }, self.backDelay);\n          } else {\n            /* call before functions if applicable */\n            if (curStrPos === 0) self.options.preStringTyped(self.arrayPos); // start typing each new char into existing string\n            // curString: arg, self.el.html: original text inside element\n\n            var nextString = curString.substr(0, curStrPos + 1);\n\n            if (self.attr) {\n              self.el.attr(self.attr, nextString);\n            } else {\n              if (self.isInput) {\n                self.el.val(nextString);\n              } else if (self.contentType === 'html') {\n                self.el.html(nextString);\n              } else {\n                self.el.text(nextString);\n              }\n            } // add characters one by one\n\n\n            curStrPos++; // loop the function\n\n            self.typewrite(curString, curStrPos);\n          } // end of character pause\n\n        }, charPause); // humanized value for typing\n      }, humanize);\n    },\n    backspace: function (curString, curStrPos) {\n      // exit when stopped\n      if (this.stop === true) {\n        return;\n      } // varying values for setTimeout during typing\n      // can't be global since number changes each time loop is executed\n\n\n      var humanize = Math.round(Math.random() * (100 - 30)) + this.backSpeed;\n      var self = this;\n      self.timeout = setTimeout(function () {\n        // ----- this part is optional ----- //\n        // check string array position\n        // on the first string, only delete one word\n        // the stopNum actually represents the amount of chars to\n        // keep in the current string. In my case it's 14.\n        // if (self.arrayPos == 1){\n        //  self.stopNum = 14;\n        // }\n        //every other time, delete the whole typed string\n        // else{\n        //  self.stopNum = 0;\n        // }\n        if (self.contentType === 'html') {\n          // skip over html tags while backspacing\n          if (curString.substr(curStrPos).charAt(0) === '>') {\n            var tag = '';\n\n            while (curString.substr(curStrPos).charAt(0) !== '<') {\n              tag -= curString.substr(curStrPos).charAt(0);\n              curStrPos--;\n            }\n\n            curStrPos--;\n            tag += '<';\n          }\n        } // ----- continue important stuff ----- //\n        // replace text with base text + typed characters\n\n\n        var nextString = curString.substr(0, curStrPos);\n\n        if (self.attr) {\n          self.el.attr(self.attr, nextString);\n        } else {\n          if (self.isInput) {\n            self.el.val(nextString);\n          } else if (self.contentType === 'html') {\n            self.el.html(nextString);\n          } else {\n            self.el.text(nextString);\n          }\n        } // if the number (id of character in current string) is\n        // less than the stop number, keep going\n\n\n        if (curStrPos > self.stopNum) {\n          // subtract characters one by one\n          curStrPos--; // loop the function\n\n          self.backspace(curString, curStrPos);\n        } // if the stop number has been reached, increase\n        // array position to next string\n        else if (curStrPos <= self.stopNum) {\n            self.arrayPos++;\n\n            if (self.arrayPos === self.strings.length) {\n              self.arrayPos = 0; // Shuffle sequence again\n\n              if (self.shuffle) self.sequence = self.shuffleArray(self.sequence);\n              self.init();\n            } else self.typewrite(self.strings[self.sequence[self.arrayPos]], curStrPos);\n          } // humanized value for typing\n\n      }, humanize);\n    }\n    /**\n     * Shuffles the numbers in the given array.\n     * @param {Array} array\n     * @returns {Array}\n     */\n    ,\n    shuffleArray: function (array) {\n      var tmp,\n          current,\n          top = array.length;\n      if (top) while (--top) {\n        current = Math.floor(Math.random() * (top + 1));\n        tmp = array[current];\n        array[current] = array[top];\n        array[top] = tmp;\n      }\n      return array;\n    } // Start & Stop currently not working\n    // , stop: function() {\n    //     var self = this;\n    //     self.stop = true;\n    //     clearInterval(self.timeout);\n    // }\n    // , start: function() {\n    //     var self = this;\n    //     if(self.stop === false)\n    //        return;\n    //     this.stop = false;\n    //     this.init();\n    // }\n    // Reset and rebuild the element\n    ,\n    reset: function () {\n      var self = this;\n      clearInterval(self.timeout);\n      var id = this.el.attr('id');\n      this.el.after('<span id=\"' + id + '\"/>');\n      this.el.remove();\n\n      if (typeof this.cursor !== 'undefined') {\n        this.cursor.remove();\n      } // Send the callback\n\n\n      self.options.resetCallback();\n    }\n  };\n\n  $.fn.typed = function (option) {\n    return this.each(function () {\n      var $this = $(this),\n          data = $this.data('typed'),\n          options = typeof option == 'object' && option;\n      if (!data) $this.data('typed', data = new Typed(this, options));\n      if (typeof option == 'string') data[option]();\n    });\n  };\n\n  $.fn.typed.defaults = {\n    strings: [\"These are the default values...\", \"You know what you should do?\", \"Use your own!\", \"Have a great day!\"],\n    stringsElement: null,\n    // typing speed\n    typeSpeed: 0,\n    // time before typing starts\n    startDelay: 0,\n    // backspacing speed\n    backSpeed: 0,\n    // shuffle the strings\n    shuffle: false,\n    // time before backspacing\n    backDelay: 500,\n    // loop\n    loop: false,\n    // false = infinite\n    loopCount: false,\n    // show cursor\n    showCursor: true,\n    // character for cursor\n    cursorChar: \"|\",\n    // attribute to type (null == text)\n    attr: null,\n    // either html or text\n    contentType: 'html',\n    // call when done callback function\n    callback: function () {},\n    // starting callback function before each string\n    preStringTyped: function () {},\n    //callback for every typed string\n    onStringTyped: function () {},\n    // callback for reset\n    resetCallback: function () {}\n  };\n}(window.jQuery);","map":{"version":3,"sources":["/home/abhishek/Desktop/Marketing app React/market/src/components/js/typed.js"],"names":["$","Typed","el","options","extend","fn","typed","defaults","isInput","is","attr","showCursor","elContent","text","contentType","typeSpeed","startDelay","backSpeed","backDelay","stringsElement","strings","strPos","arrayPos","stopNum","loop","loopCount","curLoop","stop","cursorChar","shuffle","sequence","build","prototype","constructor","init","self","timeout","setTimeout","i","length","shuffleArray","typewrite","cursor","after","hide","find","each","key","value","push","html","curString","curStrPos","humanize","Math","round","random","charPause","substr","charAt","skip","test","exec","parseInt","substring","curChar","tag","endTag","onStringTyped","callback","backspace","preStringTyped","nextString","val","array","tmp","current","top","floor","reset","clearInterval","id","remove","resetCallback","option","$this","data","window","jQuery"],"mappings":"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","sourcesContent":["// The MIT License (MIT)\n\n// Typed.js | Copyright (c) 2014 Matt Boldt | www.mattboldt.com\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n! function($) {\n\n    \"use strict\";\n\n    var Typed = function(el, options) {\n\n        // chosen element to manipulate text\n        this.el = $(el);\n\n        // options\n        this.options = $.extend({}, $.fn.typed.defaults, options);\n        // attribute to type into\n        this.isInput = this.el.is('input');\n        this.attr = this.options.attr;\n\n        // show cursor\n        this.showCursor = this.isInput ? false : this.options.showCursor;\n\n        // text content of element\n        this.elContent = this.attr ? this.el.attr(this.attr) : this.el.text()\n\n        // html or plain text\n        this.contentType = this.options.contentType;\n\n        // typing speed\n        this.typeSpeed = this.options.typeSpeed;\n\n        // add a delay before typing starts\n        this.startDelay = this.options.startDelay;\n\n        // backspacing speed\n        this.backSpeed = this.options.backSpeed;\n\n        // amount of time to wait before backspacing\n        this.backDelay = this.options.backDelay;\n\n        // div containing strings\n        this.stringsElement = this.options.stringsElement;\n\n        // input strings of text\n        this.strings = this.options.strings;\n\n        // character number position of current string\n        this.strPos = 0;\n\n        // current array position\n        this.arrayPos = 0;\n\n        // number to stop backspacing on.\n        // default 0, can change depending on how many chars\n        // you want to remove at the time\n        this.stopNum = 0;\n\n        // Looping logic\n        this.loop = this.options.loop;\n        this.loopCount = this.options.loopCount;\n        this.curLoop = 0;\n\n        // for stopping\n        this.stop = false;\n\n        // custom cursor\n        this.cursorChar = this.options.cursorChar;\n\n        // shuffle the strings\n        this.shuffle = this.options.shuffle;\n        // the order of strings\n        this.sequence = [];\n\n        // All systems go!\n        this.build();\n    };\n\n    Typed.prototype = {\n\n        constructor: Typed\n\n        ,\n        init: function() {\n            // begin the loop w/ first current string (global self.strings)\n            // current string will be passed as an argument each time after this\n            var self = this;\n            self.timeout = setTimeout(function() {\n                for (var i=0;i<self.strings.length;++i) self.sequence[i]=i;\n\n                // shuffle the array if true\n                if(self.shuffle) self.sequence = self.shuffleArray(self.sequence);\n\n                // Start typing\n                self.typewrite(self.strings[self.sequence[self.arrayPos]], self.strPos);\n            }, self.startDelay);\n        }\n\n        ,\n        build: function() {\n            var self = this;\n            // Insert cursor\n            if (this.showCursor === true) {\n                this.cursor = $(\"<span class=\\\"typed-cursor\\\">\" + this.cursorChar + \"</span>\");\n                this.el.after(this.cursor);\n            }\n            if (this.stringsElement) {\n                self.strings = [];\n                this.stringsElement.hide();\n                var strings = this.stringsElement.find('p');\n                $.each(strings, function(key, value){\n                    self.strings.push($(value).html());\n                });\n            }\n            this.init();\n        }\n\n        // pass current string state to each function, types 1 char per call\n        ,\n        typewrite: function(curString, curStrPos) {\n            // exit when stopped\n            if (this.stop === true) {\n                return;\n            }\n\n            // varying values for setTimeout during typing\n            // can't be global since number changes each time loop is executed\n            var humanize = Math.round(Math.random() * (100 - 30)) + this.typeSpeed;\n            var self = this;\n\n            // ------------- optional ------------- //\n            // backpaces a certain string faster\n            // ------------------------------------ //\n            // if (self.arrayPos == 1){\n            //  self.backDelay = 50;\n            // }\n            // else{ self.backDelay = 500; }\n\n            // contain typing function in a timeout humanize'd delay\n            self.timeout = setTimeout(function() {\n                // check for an escape character before a pause value\n                // format: \\^\\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^\n                // single ^ are removed from string\n                var charPause = 0;\n                var substr = curString.substr(curStrPos);\n                if (substr.charAt(0) === '^') {\n                    var skip = 1; // skip atleast 1\n                    if (/^\\^\\d+/.test(substr)) {\n                        substr = /\\d+/.exec(substr)[0];\n                        skip += substr.length;\n                        charPause = parseInt(substr);\n                    }\n\n                    // strip out the escape character and pause value so they're not printed\n                    curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);\n                }\n\n                if (self.contentType === 'html') {\n                    // skip over html tags while typing\n                    var curChar = curString.substr(curStrPos).charAt(0)\n                    if (curChar === '<' || curChar === '&') {\n                        var tag = '';\n                        var endTag = '';\n                        if (curChar === '<') {\n                            endTag = '>'\n                        } else {\n                            endTag = ';'\n                        }\n                        while (curString.substr(curStrPos).charAt(0) !== endTag) {\n                            tag += curString.substr(curStrPos).charAt(0);\n                            curStrPos++;\n                        }\n                        curStrPos++;\n                        tag += endTag;\n                    }\n                }\n\n                // timeout for any pause after a character\n                self.timeout = setTimeout(function() {\n                    if (curStrPos === curString.length) {\n                        // fires callback function\n                        self.options.onStringTyped(self.arrayPos);\n\n                        // is this the final string\n                        if (self.arrayPos === self.strings.length - 1) {\n                            // animation that occurs on the last typed string\n                            self.options.callback();\n\n                            self.curLoop++;\n\n                            // quit if we wont loop back\n                            if (self.loop === false || self.curLoop === self.loopCount)\n                                return;\n                        }\n\n                        self.timeout = setTimeout(function() {\n                            self.backspace(curString, curStrPos);\n                        }, self.backDelay);\n                    } else {\n\n                        /* call before functions if applicable */\n                        if (curStrPos === 0)\n                            self.options.preStringTyped(self.arrayPos);\n\n                        // start typing each new char into existing string\n                        // curString: arg, self.el.html: original text inside element\n                        var nextString = curString.substr(0, curStrPos + 1);\n                        if (self.attr) {\n                            self.el.attr(self.attr, nextString);\n                        } else {\n                            if (self.isInput) {\n                                self.el.val(nextString);\n                            } else if (self.contentType === 'html') {\n                                self.el.html(nextString);\n                            } else {\n                                self.el.text(nextString);\n                            }\n                        }\n\n                        // add characters one by one\n                        curStrPos++;\n                        // loop the function\n                        self.typewrite(curString, curStrPos);\n                    }\n                    // end of character pause\n                }, charPause);\n\n                // humanized value for typing\n            }, humanize);\n\n        }\n\n        ,\n        backspace: function(curString, curStrPos) {\n            // exit when stopped\n            if (this.stop === true) {\n                return;\n            }\n\n            // varying values for setTimeout during typing\n            // can't be global since number changes each time loop is executed\n            var humanize = Math.round(Math.random() * (100 - 30)) + this.backSpeed;\n            var self = this;\n\n            self.timeout = setTimeout(function() {\n\n                // ----- this part is optional ----- //\n                // check string array position\n                // on the first string, only delete one word\n                // the stopNum actually represents the amount of chars to\n                // keep in the current string. In my case it's 14.\n                // if (self.arrayPos == 1){\n                //  self.stopNum = 14;\n                // }\n                //every other time, delete the whole typed string\n                // else{\n                //  self.stopNum = 0;\n                // }\n\n                if (self.contentType === 'html') {\n                    // skip over html tags while backspacing\n                    if (curString.substr(curStrPos).charAt(0) === '>') {\n                        var tag = '';\n                        while (curString.substr(curStrPos).charAt(0) !== '<') {\n                            tag -= curString.substr(curStrPos).charAt(0);\n                            curStrPos--;\n                        }\n                        curStrPos--;\n                        tag += '<';\n                    }\n                }\n\n                // ----- continue important stuff ----- //\n                // replace text with base text + typed characters\n                var nextString = curString.substr(0, curStrPos);\n                if (self.attr) {\n                    self.el.attr(self.attr, nextString);\n                } else {\n                    if (self.isInput) {\n                        self.el.val(nextString);\n                    } else if (self.contentType === 'html') {\n                        self.el.html(nextString);\n                    } else {\n                        self.el.text(nextString);\n                    }\n                }\n\n                // if the number (id of character in current string) is\n                // less than the stop number, keep going\n                if (curStrPos > self.stopNum) {\n                    // subtract characters one by one\n                    curStrPos--;\n                    // loop the function\n                    self.backspace(curString, curStrPos);\n                }\n                // if the stop number has been reached, increase\n                // array position to next string\n                else if (curStrPos <= self.stopNum) {\n                    self.arrayPos++;\n\n                    if (self.arrayPos === self.strings.length) {\n                        self.arrayPos = 0;\n\n                        // Shuffle sequence again\n                        if(self.shuffle) self.sequence = self.shuffleArray(self.sequence);\n\n                        self.init();\n                    } else\n                        self.typewrite(self.strings[self.sequence[self.arrayPos]], curStrPos);\n                }\n\n                // humanized value for typing\n            }, humanize);\n\n        }\n        /**\n         * Shuffles the numbers in the given array.\n         * @param {Array} array\n         * @returns {Array}\n         */\n        ,shuffleArray: function(array) {\n            var tmp, current, top = array.length;\n            if(top) while(--top) {\n                current = Math.floor(Math.random() * (top + 1));\n                tmp = array[current];\n                array[current] = array[top];\n                array[top] = tmp;\n            }\n            return array;\n        }\n\n        // Start & Stop currently not working\n\n        // , stop: function() {\n        //     var self = this;\n\n        //     self.stop = true;\n        //     clearInterval(self.timeout);\n        // }\n\n        // , start: function() {\n        //     var self = this;\n        //     if(self.stop === false)\n        //        return;\n\n        //     this.stop = false;\n        //     this.init();\n        // }\n\n        // Reset and rebuild the element\n        ,\n        reset: function() {\n            var self = this;\n            clearInterval(self.timeout);\n            var id = this.el.attr('id');\n            this.el.after('<span id=\"' + id + '\"/>')\n            this.el.remove();\n            if (typeof this.cursor !== 'undefined') {\n                this.cursor.remove();\n            }\n            // Send the callback\n            self.options.resetCallback();\n        }\n\n    };\n\n    $.fn.typed = function(option) {\n        return this.each(function() {\n            var $this = $(this),\n                data = $this.data('typed'),\n                options = typeof option == 'object' && option;\n            if (!data) $this.data('typed', (data = new Typed(this, options)));\n            if (typeof option == 'string') data[option]();\n        });\n    };\n\n    $.fn.typed.defaults = {\n        strings: [\"These are the default values...\", \"You know what you should do?\", \"Use your own!\", \"Have a great day!\"],\n        stringsElement: null,\n        // typing speed\n        typeSpeed: 0,\n        // time before typing starts\n        startDelay: 0,\n        // backspacing speed\n        backSpeed: 0,\n        // shuffle the strings\n        shuffle: false,\n        // time before backspacing\n        backDelay: 500,\n        // loop\n        loop: false,\n        // false = infinite\n        loopCount: false,\n        // show cursor\n        showCursor: true,\n        // character for cursor\n        cursorChar: \"|\",\n        // attribute to type (null == text)\n        attr: null,\n        // either html or text\n        contentType: 'html',\n        // call when done callback function\n        callback: function() {},\n        // starting callback function before each string\n        preStringTyped: function() {},\n        //callback for every typed string\n        onStringTyped: function() {},\n        // callback for reset\n        resetCallback: function() {}\n    };\n\n\n}(window.jQuery);\n"]},"metadata":{},"sourceType":"module"}